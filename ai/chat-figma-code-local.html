<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Figma Code Generator - Local</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f5f7fa; min-height: 100vh; display: flex; align-items: center; justify-content: center; }
    .chat-container { width: 92%; max-width: 900px; background: white; border-radius: 16px; box-shadow: 0 14px 40px rgba(0,0,0,0.12); overflow: hidden; display: flex; flex-direction: column; }
    .chat-header { background: linear-gradient(135deg, #0ea5e9 0%, #6366f1 100%); color: white; padding: 18px 22px; }
    .chat-header h1 { font-size: 1.1rem; }
    .chat-messages { padding: 18px; height: 60vh; overflow: auto; background: #fafafa; display: flex; flex-direction: column; gap: 12px; }
    .message { max-width: 85%; padding: 12px 14px; border-radius: 16px; }
    .message.user { align-self: flex-end; background: #0ea5e9; color: #fff; border-bottom-right-radius: 6px; }
    .message.ai { align-self: flex-start; background: #fff; color: #222; border: 1px solid #e5e7eb; border-bottom-left-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.06); }
    .message .timestamp { font-size: 0.75em; opacity: 0.65; margin-top: 6px; }
  /* Loading indicator */
  .typing { align-self: flex-start; background: #fff; color: #222; border: 1px solid #e5e7eb; border-bottom-left-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.06); }
  .typing-bubble { display: inline-flex; gap: 6px; align-items: center; }
  .typing-dot { width: 8px; height: 8px; background: #0ea5e9; border-radius: 50%; animation: typing 1.2s infinite ease-in-out; }
  .typing-dot:nth-child(2) { animation-delay: 0.15s; }
  .typing-dot:nth-child(3) { animation-delay: 0.3s; }
  @keyframes typing { 0%, 60%, 100% { transform: translateY(0); } 30% { transform: translateY(-8px); } }
  .inputs { display: grid; grid-template-columns: 1fr auto; gap: 10px; padding: 14px; background: #fff; border-top: 1px solid #e5e7eb; }
  .text-input { padding: 10px 12px; border: 2px solid #e5e7eb; border-radius: 14px; font-size: 0.95rem; outline: none; }
  .text-input:focus { border-color: #0ea5e9; }
    .send { background: linear-gradient(135deg, #0ea5e9 0%, #6366f1 100%); color: white; border: none; padding: 0 18px; border-radius: 14px; cursor: pointer; font-weight: 600; }
    .send:disabled { opacity: 0.6; cursor: not-allowed; }
    pre { background: #0f172a; color: #e2e8f0; padding: 12px 14px; border-radius: 10px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size: 0.9em; line-height: 1.45; border: 1px solid #0b1220; margin: 8px 0; position: relative; }
    code { background: #f1f5f9; color: #0f172a; padding: 2px 6px; border-radius: 6px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size: 0.95em; }
    pre code { background: transparent; padding: 0; color: #e2e8f0; }
    .code-block-container { position: relative; margin: 8px 0; }
    .copy-btn { position: absolute; top: 8px; right: 8px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); color: #e2e8f0; border-radius: 6px; padding: 6px 10px; font-size: 0.75em; cursor: pointer; transition: all 0.2s ease; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; }
    .copy-btn:hover { background: rgba(255, 255, 255, 0.2); border-color: rgba(255, 255, 255, 0.3); }
    .copy-btn.copied { background: #10b981; border-color: #10b981; color: white; }
    @media (max-width: 840px) { .inputs { grid-template-columns: 1fr; } }
  </style>
  </head>
  <body>
    <div class="chat-container">
      <div class="chat-header">
        <h1>Figma Code Generator (Local)</h1>
  <div style="opacity:0.85;font-size:0.9rem;margin-top:4px;">Posts to http://localhost:5678/webhook-test/figma-code</div>
  <div style="opacity:0.75;font-size:0.9rem;margin-top:6px;">Example: Generate a table for orders https://www.figma.com/design/FILE/NAME?node-id=26123-264462</div>
      </div>
      <div id="messages" class="chat-messages"></div>
      <div class="inputs">
  <input id="chatInput" class="text-input" placeholder="Paste a Figma URL and/or add instructions. Example: Generate a table for orders https://www.figma.com/design/...?...node-id=26123-264462" maxlength="600" />
        <button id="send" class="send" onclick="send()">Send</button>
      </div>
    </div>

    <script>
  // const URL_ENDPOINT = 'http://localhost:5678/webhook-test/figma-code';
  const URL_ENDPOINT = 'http://localhost:5678/webhook/figma-code';
  // Increase or disable timeout: set to 0 to disable client timeout entirely
  const TIMEOUT_MS = 120000; // 2 minutes
      const messages = document.getElementById('messages');
      const chatInput = document.getElementById('chatInput');
      const sendBtn = document.getElementById('send');

      window.addEventListener('load', () => chatInput.focus());
      document.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && document.activeElement === chatInput && !sendBtn.disabled) send();
      });

  // Optionally react to paste/input (informational only)
  chatInput.addEventListener('paste', () => {/* URL extraction happens at send time */});
  chatInput.addEventListener('input', () => {/* URL extraction happens at send time */});

      function addMessage(type, content) {
        const div = document.createElement('div');
        div.className = 'message ' + type;
        const ts = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        div.innerHTML = `<div>${render(content)}</div><div class="timestamp">${ts}</div>`;
        messages.appendChild(div);
        messages.scrollTop = messages.scrollHeight;
      }

      function showTyping() {
        if (document.getElementById('typingIndicator')) return;
        const div = document.createElement('div');
        div.className = 'message typing';
        div.id = 'typingIndicator';
        div.innerHTML = `<div class="typing-bubble"><span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span></div>`;
        messages.appendChild(div);
        messages.scrollTop = messages.scrollHeight;
      }

      function hideTyping() {
        const el = document.getElementById('typingIndicator');
        if (el) el.remove();
      }

      function render(text) {
        if (!text) return '';
        
        // Convert text to string and normalize line endings
        let t = ('' + text).replace(/\r\n/g, '\n');
        
        // Handle fenced code blocks with copy buttons
        let codeBlockId = 0;
        let codeBlocks = [];
        
        t = t.replace(/```([\w-]+)?\n?([\s\S]*?)```/g, (match, lang, code) => {
          const id = `code-block-${codeBlockId++}`;
          const cleanCode = code.trim();
          const langClass = lang ? ` class="language-${lang}"` : '';
          const placeholder = `__CODE_BLOCK_${id}__`;
          
          codeBlocks.push({
            placeholder,
            html: `<div class="code-block-container">
              <pre><code${langClass}>${escapeHtml(cleanCode)}</code></pre>
              <button class="copy-btn" onclick="copyCodeToClipboard('${id}', this)" data-code="${escapeHtml(cleanCode).replace(/"/g, '&quot;')}">Copy</button>
            </div>`
          });
          
          return placeholder;
        });
        
        // Escape HTML for the rest of the content
        t = escapeHtml(t);
        
        // Handle inline code
        t = t.replace(/`([^`]+)`/g, '<code>$1</code>');
        
        // Handle bold and italic
        t = t.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
        t = t.replace(/\*(.+?)\*/g, '<em>$1</em>');
        
        // Handle bullets
        t = t.replace(/^• (.*)$/gim, '&bull; $1');
        
        // Handle line breaks
        t = t.replace(/\n/g, '<br>');
        
        // Restore code blocks
        codeBlocks.forEach(block => {
          t = t.replace(block.placeholder, block.html);
        });
        
        return t;
      }

      function escapeHtml(s){
        return (s||'').replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[ch]));
      }

      // Copy code to clipboard
      async function copyCodeToClipboard(codeId, buttonElement) {
        try {
          const code = buttonElement.getAttribute('data-code');
          const decodedCode = code.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&amp;/g, '&');
          
          await navigator.clipboard.writeText(decodedCode);
          
          const originalText = buttonElement.textContent;
          buttonElement.textContent = 'Copied!';
          buttonElement.classList.add('copied');
          
          setTimeout(() => {
            buttonElement.textContent = originalText;
            buttonElement.classList.remove('copied');
          }, 2000);
        } catch (err) {
          console.error('Failed to copy code:', err);
          buttonElement.textContent = 'Failed';
          setTimeout(() => {
            buttonElement.textContent = 'Copy';
          }, 2000);
        }
      }

      async function send() {
        const raw = chatInput.value.trim();
        const parsed = parseChatAndNode(raw);
        // If no URL and empty text, do nothing
        if (!parsed.text) return;
        sendBtn.disabled = true;
        addMessage('user', parsed.nodeId ? parsed.text + `\n(figma_node_id: ${parsed.nodeId})` : parsed.text);
        try {
          showTyping();
          const controller = new AbortController();
          let abortedByTimeout = false;
          let timeoutId = null;
          if (TIMEOUT_MS > 0) {
            timeoutId = setTimeout(() => { abortedByTimeout = true; controller.abort(); }, TIMEOUT_MS);
          }
          const payload = { chatInput: parsed.text };
          if (parsed.nodeId) payload.figma_node_id = parsed.nodeId;
          const res = await fetch(URL_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            signal: controller.signal,
          });
          hideTyping();
          if (!res.ok) {
            let errText = '';
            try { errText = (await res.text()).slice(0, 300); } catch {}
            throw new Error(`HTTP ${res.status} ${res.statusText}${errText ? ` - ${errText}` : ''}`);
          }
          const rawText = await res.text();
          let out = rawText;
          try {
            const j = JSON.parse(rawText);
            // Handle array response format
            if (Array.isArray(j) && j.length > 0 && j[0].output) {
              out = j[0].output;
            } else {
              out = j.output || j.response || j.message || JSON.stringify(j, null, 2);
            }
          } catch {}
          addMessage('ai', out);
          // success: clear input
          chatInput.value = '';
        } catch (e) {
          hideTyping();
          let msg = String(e && e.message || e);
          // Timeout / Abort handling
          if (e && e.name === 'AbortError' && abortedByTimeout) {
            const secs = Math.round((TIMEOUT_MS || 0) / 1000);
            msg = `⏰ Client timed out after ${secs}s. The server may still be processing.`;
          } else if (/failed to fetch|networkerror|load failed/i.test(msg)) {
            msg = '🌐 Network error. Unable to reach http://localhost:5678. Ensure n8n is running and check CORS.';
          }
          addMessage('ai', `❌ ${msg}\n\nTips:\n• Start n8n and activate the workflow\n• Verify URL: http://localhost:5678/webhook-test/figma-code\n• Keep this page served over http:// (not file://) to avoid CORS issues\n• Increase TIMEOUT_MS (currently ${TIMEOUT_MS}ms) or set 0 to disable\n• Try again after a few seconds`);
        } finally {
          sendBtn.disabled = false;
          chatInput.focus();
          try { if (timeoutId) clearTimeout(timeoutId); } catch {}
        }
      }

      function parseChatAndNode(value) {
        const valueStr = value || '';
        const url = findFirstFigmaUrl(valueStr);
        const nodeId = url ? extractFigmaNodeIdFromText(url) : null;
        // Remove the found URL from the text to get the prompt
        let text = valueStr;
        if (url) {
          text = text.replace(url, '').trim();
          if (!text) text = 'Generate code';
        }
        return { text, nodeId };
      }

      function findFirstFigmaUrl(text) {
        if (!text) return null;
        const m = text.match(/https?:\/\/(?:www\.)?figma\.com\/[\w\-/.?=#%:&]+/i);
        return m ? m[0] : null;
      }

      function extractFigmaNodeIdFromText(text) {
        if (!text) return null;
        try {
          // Find first figma URL in the text
          const match = text.match(/https?:\/\/(?:www\.)?figma\.com\/[\w\-/.?=#%:&]+/i);
          const urlStr = match ? match[0] : (text.startsWith('http') ? text : null);
          if (!urlStr) return null;
          const url = new URL(urlStr);
          // Helper to read node-id from a query-like string
          const getNodeFrom = (q) => {
            if (!q) return null;
            const s = q.startsWith('?') || q.startsWith('#') ? q.slice(1) : q;
            const params = new URLSearchParams(s);
            let id = params.get('node-id') || params.get('node_id');
            if (!id) return null;
            id = decodeURIComponent(id);
            if (!id.includes(':')) {
              // Convert first hyphen to colon if needed (e.g., 26123-264462 -> 26123:264462)
              const hy = id.indexOf('-');
              if (hy > 0) id = id.slice(0, hy) + ':' + id.slice(hy + 1);
            }
            return id;
          };
          return getNodeFrom(url.search) || getNodeFrom(url.hash);
        } catch { return null; }
      }
    </script>
  </body>
  </html>
